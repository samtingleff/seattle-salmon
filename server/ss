#!/usr/bin/env python

import os
import logging
import sys
import struct
import daemon

sys.path.append("..")
sys.path.append(os.path.join(sys.path[0], '..'))

from storage.bdb import BTree
from storage.queue import QueuedStorage, QueueFullException
from memcache import binary, constants

from twisted.application import internet, service
from twisted.internet import reactor, protocol, defer, task
from twisted.python import components
from twisted.web import resource, server

from memcache import binary, constants

class DummyStorage(object):

    def get(self, key, data): pass

    def set(self, key, data): pass

    def delete(self, key, data): pass

    def flush(self): pass

    def sync(self): pass

class MemcachedBinaryProtocol(binary.BinaryServerProtocol):
    storage = DummyStorage()
    default_flags, default_expires, default_cas = 0, 0, 0
    version = "0.0.1"

    def set_storage(cls, storage_impl):
        MemcachedBinaryProtocol.storage = storage_impl
    set_storage = classmethod(set_storage)

    def get(req, data):
        val = MemcachedBinaryProtocol.storage.get(req.key)
        if val: return binary.GetResponse(req,
                MemcachedBinaryProtocol.default_flags, MemcachedBinaryProtocol.default_cas, data=val)
        else: raise binary.MemcachedNotFound()

    def noop(req, data): return binary.Response(req)

    def set(req, data):
        try:
            flags, exp = struct.unpack(constants.SET_PKT_FMT, req.extra)
            MemcachedBinaryProtocol.storage.set(req.key, data)
        except Exception, e:
            raise binary.MemcachedError()

    def delete(req, data):
        try:
            return MemcachedBinaryProtocol.storage.delete(req.key)
        except KeyError: raise binary.MemcachedNotFound()
        except Exception: raise binary.MemcachedError()

    def quit(*a): raise binary.MemcachedDisconnect()

    def version(req, data):
        return binary.Response(req, data=MemcachedBinaryProtocol.version)

    def flush(): return MemcachedBinaryProtocol.storage.flush()

    def sync(): return MemcachedBinaryProtocol.storage.sync()

    handlers = {
        constants.CMD_GET: get,
        constants.CMD_GETQ: get,
        constants.CMD_NOOP: noop,
        constants.CMD_SET: set,
        constants.CMD_DELETE: delete,
        constants.CMD_VERSION: version,
        constants.CMD_QUIT: quit
    }

class WebResourceAdapter(resource.Resource):
    isLeaf = True

    def __init__(self, storage):
        self.storage = storage

    def render_GET(self, request):
        key = request.path[1:]
        val = self.storage.get(key)
        request.setResponseCode((200, 404)[val is None])
        request.write((val, 'Not found')[val is None])
        request.finish()
        return server.NOT_DONE_YET

    def render_PUT(self, request):
        key = request.path[1:]
        data = request.content.getvalue()
        self.storage.set(key, data)
        return 'Saved'

    def render_DELETE(self, request):
        key = request.path[1:]
        try:
            self.storage.delete(key)
            return 'Deleted'
        except KeyError:
            request.setResponseCode(404)
            return 'Not found'

class SeattleSalmon(daemon.Daemon):
    default_conf = '/etc/seattle-salmon.conf'
    default_memcached_port = 8089
    default_http_port = 8090
    section = 'daemon'

    def run(self):
        factory = protocol.Factory()
        bdb = BTree(
                self.get_option('bdb', 'data-dir', default='tmp/data'),
                self.get_option('bdb', 'log-dir', default='tmp/logs'),
                self.get_int_option('bdb', 'splits', default=1),
                cache_gbytes=self.get_int_option('bdb', 'cache-gbytes', default=1),
                cache_bytes=self.get_int_option('bdb', 'cache-bytes', default=0),
                lk_max_locks=self.get_int_option('bdb', 'lk-max-locks', default=1000),
                lk_max_lockers=self.get_int_option('bdb', 'lk-max-lockers', default=1000),
                lk_max_objects=self.get_int_option('bdb', 'lk-max-objects', default=1000))

        if bool(self.get_bool_option('bdb', 'queue-writes', default=False)):
            storage = QueuedStorage(bdb, limit=self.get_int_option('bdb', 'queue-writes-limit', default=10000))
        else: storage = bdb

        MemcachedBinaryProtocol.set_storage(storage)
        factory.protocol = MemcachedBinaryProtocol

        # memcached binary protocol
        memcached_port = int(self.get_option('memcached', 'port', default=self.default_memcached_port))
        if memcached_port != 0: reactor.listenTCP(memcached_port, factory)

        # http protocol
        http_port = int(self.get_option('http', 'port', default=self.default_http_port))
        if http_port != 0:
            site = server.Site(WebResourceAdapter(storage))
            reactor.listenTCP(http_port, site)

        # call flush() every x seconds
        # this appears to be the only way to get a repeating task that runs outside of the main thread
        flush_task = task.LoopingCall(lambda: reactor.callInThread(storage.flush))
        flush_task.start(int(self.get_int_option('bdb', 'flush-frequency', default=5)), now=False)

        # call sync() every y seconds
        sync_task = task.LoopingCall(lambda: reactor.callInThread(storage.sync))
        sync_task.start(int(self.get_int_option('bdb', 'sync-frequency', default=60)), now=False)

        reactor.run()

if __name__ == '__main__':
    ss = SeattleSalmon()
    ss.parse_options()
    ss.main()
    #ss.read_basic_config()
    #ss.run()

