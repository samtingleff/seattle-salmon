#!/usr/bin/env python

import os
import logging
import sys
import struct
import daemon

sys.path.append("..")
sys.path.append(os.path.join(sys.path[0], '..'))

from storage.bdb import BTree

from twisted.application import internet, service
from twisted.internet import reactor, protocol, defer, task
from twisted.python import components
from zope.interface import Interface, implements

from memcache import binary, constants

class DummyStorage(object):

    def doGet(self, key, data): pass

    def doSet(self, key, data): pass

    def doDelete(self, key, data): pass

    def doQuit(self, key, data): pass

    def sync(self): pass

class SimpleBinaryServer(binary.BinaryServerProtocol):
    storage = DummyStorage()

    def set_storage(cls, storage_impl):
        SimpleBinaryServer.storage = storage_impl
    set_storage = classmethod(set_storage)

    def doGet(req, data): return SimpleBinaryServer.storage.doGet(req, data)

    def doSet(req, data): return SimpleBinaryServer.storage.doSet(req, data)

    def doDelete(req, data): return SimpleBinaryServer.storage.doDelete(req, data)

    def doQuit(*a): return SimpleBinaryServer.storage.doQuit(a)

    def sync(): return SimpleBinaryServer.storage.sync()

    handlers = {
        constants.CMD_GET: doGet,
        constants.CMD_SET: doSet,
        constants.CMD_DELETE: doDelete,
        constants.CMD_QUIT: doQuit
    }

class SeattleSalmon(daemon.Daemon):
    default_conf = '/etc/seattle-salmon.conf'
    default_port = 8089
    section = 'daemon'

    def run(self):
        factory = protocol.Factory()
        storage = BTree(
                self.get_option('bdb', 'data-dir', default='tmp/data'),
                self.get_option('bdb', 'log-dir', default='tmp/logs'),
                cache_gbytes=int(self.get_option('bdb', 'cache-gbytes', default='1')),
                cache_bytes=int(self.get_option('bdb', 'cache-bytes', default='0')))
        SimpleBinaryServer.set_storage(storage)
        factory.protocol = SimpleBinaryServer

        # memcached binary protocol
        port = int(self.get_option(self.section, 'port', default=self.default_port))
        reactor.listenTCP(port, factory)

        # this appears to be the only way to get a repeating task that runs outside of the main thread
        repeatingTask = task.LoopingCall(lambda: reactor.callInThread(storage.sync))
        repeatingTask.start(int(self.get_option('bdb', 'sync-frequency', default='60')), now=False)

        reactor.run()

if __name__ == '__main__':
    ss = SeattleSalmon()
    ss.parse_options()
    ss.main()
    #ss.read_basic_config()
    #ss.run()

